(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{507:function(l,i,n){"use strict";n.r(i);var v=n(2),t=Object(v.a)({},(function(){var l=this,i=l._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[i("h1",{attrs:{id:"java静态变量、inline初始化的实例变量-显示与隐式调用构造器的执行顺序"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java静态变量、inline初始化的实例变量-显示与隐式调用构造器的执行顺序"}},[l._v("#")]),l._v(" Java静态变量、inline初始化的实例变量，显示与隐式调用构造器的执行顺序")]),l._v(" "),i("ol",[i("li",[l._v("所有依赖路径的类（包括父类与子类）加载，类变量初始化和静态代码块执行，注意一个类只会被加载一次，顺序如下：\n"),i("ol",[i("li",[l._v("加载父类，其中类加载过程中类变量和静态变量的顺序如下：\n"),i("ol",[i("li",[l._v("静态变量")]),l._v(" "),i("li",[l._v("静态代码块")])])]),l._v(" "),i("li",[l._v("加载子类，顺序同上")])])]),l._v(" "),i("li",[l._v("实例变量初始化与构造器调用，先执行父类，再执行子类，注意每次新建类的实例时都会完整执行一遍\n"),i("ol",[i("li",[l._v("父类实例变量初始化与构造器\n"),i("ol",[i("li",[l._v("父类inline实例变量初始化过程")]),l._v(" "),i("li",[l._v("父类构造器，如果子类被调用到的构造器中通过super()或者super(param)显式调用了父构造器，则执行被调用的构造器，否则执行空构造器")])])]),l._v(" "),i("li",[l._v("子类实例变量初始化与构造器\n"),i("ol",[i("li",[l._v("子类inline实例变量初始化过程")]),l._v(" "),i("li",[l._v("子类构造器调用，被调用哪个就执行哪个，除非显式调用this()，否则不会调用子类的空构造器")])])])])])]),l._v(" "),i("p",[l._v("因此，反直觉的是，反而是调用到的子类的构造方法，最后被执行")])])}),[],!1,null,null,null);i.default=t.exports}}]);
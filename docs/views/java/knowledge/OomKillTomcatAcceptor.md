---
date: 2023-01-07 20:43:03
categories:
  - 懂
tags:
  - Tomcat
  - 故障
  - 问题
publish: false
---

# OOM导致的服务异常且不自动恢复

某日，正在愉快的冲浪，收到同事的告警:“xx服务预发环境挂了，高频报超时和404错误，在发布？”

由于是预发环境，且整体影响面不大（只是间歇不可用），有足够的时间慢慢排查，因此暂时没有回滚。

## 404问题

404错误一般是由于预发环境仅单节点，服务因为FullGC等原因健康检查失败导致被注册中心摘除后，暂时没有服务提供者导致，对于线上环境会快速拉起新容器短暂恢复，对于预发环境一般需要等服务恢复后重新注册，然后又出现问题

- 查看注册中心事件日志发现确实持续有节点健康检查失败事件
- 容器内部检查后发现
- 可以确认问题原因（之一）是服务出现了某些异常导致健康检查失败，考虑到调用方有较多的超时报错，从此处入手是一个不错的思路

## 健康检查失败叠加双超时的一般思路

接口调用超时一般分为2种，建连超时（```connectionTimeout```）和响应读取超时（```socketReadTimeout```）,按一般经验，当出现某接口RT高时，两者会交替出现

1. 最初是接口RT高，调用方报错超时（也有可能不报错，看调用方的容忍度），本服务Tomcat线程堆积
   - 这里与接口RT(ms)，QPS，Tomcat最大线程数3个参数有关，当3者出现如下关系时，会导致Tomcat线程持续堆积，即线程无法即使处理请求并释放到线程池
   - ![QpsRTThread2](https://cdn.jsdelivr.net/gh/kkyeer/picbed/QpsRTThread2.svg)
   - 注意这里是假定服务只有一个接口，实际上服务同时有很多接口所以会有所偏差
   - 举例，一般来说Tomcat线程池默认200，假设某接口集群QPS为20000，集群规模50，则单节点承受400QPS压力，此时接口RT至少要保持在 200*1000/400=500ms 以下才可保证线程池始终有可用的线程

2. Tomcat线程很快达到最大线程数，线程池没有线程来立即处理请求，此时请求排队进行处理，上游```socketReadTimeout```超时报错逐渐增多
3. 线程堆积到一定程度，开始拒绝TCP连接，此时上游开始报错```connectionTimeout```，建立连接失败
4. 与此同时，健康检查调用```/actuator/health```接口也超时，此时被暂时从注册中心摘除
5. 随着被注册中心摘除，新请求暂时不会调用到问题pod，积压请求处理完成后，pod恢复正常，健康检查成功，重新放入注册中心
6. 由于接口RT仍旧存在问题，如此往复

## 接口RT高？

根据上面的分析，碰到双超时出现，首先分析接口RT，90%的情况下通过接口监控定位到特别慢的接口，再结合调用链监控或者性能剖析，定位到具体的代码位置可解决。

但是这次通过接口定位发现所有接口的RT都有大幅上升，一般这种情况下是出现了性能瓶颈导致整体接口性能下降。

## 为什么没有自动恢复？
